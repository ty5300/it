 

 * 연산자(Operator)  : 연산을 수행하는 기호 ( + ,  - ,  * ,  / ,  % 등)
 *피연산자(Operand)  : 연산자의 작업 대상( 변수 ,  상수 ,  리터럴 ,  수식 )
 

|우선순위	|종류|	연산자|	결합방향|
|---|---|---|---|
|1|	최우선연산자|	 ( )   [ ]    .   ->|	좌 → 우||
|2|	단항연산자|	 ++ ,  -- ,  + ,  - ,  ~ ,  !(type) |	좌 ← 우|
|3|	산술연산자|	 * ,  / , % , +, - |	좌 → 우|
|4|	쉬프트(비트이동)연산자|	 << ,  >> 	|좌 → 우|
|5|	관계연산자|	 < ,  <= ,  > ,  >= ,  == ,  != 	|좌 → 우|
|6|	비트논리연산자|	 & , \| ,  ^ |	좌 → 우|
|7|	논리연산자|	 && ,  || 	|좌 → 우|
|8|	삼항연산자|	 ? :  	|좌 ← 우|
|9|	대입연산자| = ,  += ,  -= ,  *= ,  /= ,  %= ,  <<=,  >== ,  &= ,  ^= ,  != |좌 ← 우|

연산자 순위가 높은 순서대로 먼저 계산된다!

 

피연산자의 개수에 의한 분류
: 개수가 1개이면 단항 연산자, 2개이면 이항 연산자, 3개면 삼항 연산자라고 한다.
산술 변환
: 이항 연산자는 두 피연산자의 타입이 일치해야 계산이 가능하므로 연산 전에 형 변환해서 타입을 맞춰주어야 한다.
(작은 타입에서 큰 타입으로 형변환 하는 경우에는 자동형변환되어 생략 가능)

+ 연산 결과의 타입은 피연산자의 타입과 일치한다
ex)  5 / 2  →  2    : 5나 2를  double 이나  float 으로 형변환 해주어야  2.5 가 나온다!
 

 

 

연산자의 종류
  ■ 단항 연산자 

  1. 증감 연산자 (++, --)  

      : 값을  증가 시키거나  감소 시킨다. (상수는 불가능)

       먼저 값을  증가 / 감소 시키는 전위형(prefix)과 나중에 값을  증가 / 감소 시키는 후위형(postfix)이 있다.

       이해하기 어렵다면 해당 코드가 있는 줄을 기준으로 생각하면 쉽다.  전위형 은 미리 계산하고 나서 값을 넣는 것이고,  후위형 은 줄이 끝난 뒤에 계산이 된다고 생각하면 된다.

 

int i = 5, j = 5;
System.out.println(i++);	// 5가 출력되고 나서 1이 증가된 6이 i에 저장됨
System.out.println(++j);	// 먼저 1이 증가된 6이 출력됨, i에 저장된 값도 6
System.out.println("i = " + i + ", j = " + j);
 


결과값
  2. 부호 연산자(+, -)

      :  - 는 부호를 반대로 변경한 결과를 반환한다(음수 → 양수 / 양수 → 음수)

      부호 연산자는  boolean 과  char 를 제외한 기본형에만 사용할 수 있다.

 

 

  ■ 산술 연산자 (+, -, *, /, %)

  : 사칙연산은 우리가 알고 있는 것과 같다. 주의할 점은  / 는 0으로 나눌 수 없다는 것이다.  % 는 나머지 연산자로 몫으로 나눈 나머지를 반환한다. 나누는 수로 음수도 허용하지만 부호는 무시된다.  % 역시 0으로 나눌 수 없다. 

  ex)  5 % 2  →  1 

 

 

  ■ 비트 연산자(&, |, ^, ~, >>, <<)

    1. 비트 논리 연산자 (|, &, ^)  

       : 비트단위로 연산한 값을 반환하고 실수는 허용하지 않는다.(정수와 문자만 허용)

        | 는 OR연산,  & 는 AND연산,  ^ 는 XOR연산(서로 다를 때만 참)을 수행한다.

X	Y	X | Y	X & Y	X ^ Y
1	1	1	1	0
1	0	1	0	1
0	1	1	0	1
0	0	0	0	0
 

    2. 비트 전환 연산자(~)

       : 피연산자를 2진수로 표현했을 때 0은 1로, 1은 0으로 바꾼다. 

X	~X
1	0
0	1
 

    3. 쉬프트 연산자(<<, >>)

 <<  : 부호에 상관없이 2진수를 표현한 값들을 왼쪽으로 2자리 이동시킨다.
       자리에서 벗어난 값들은 버려지고 빈자리는  0 으로 채운다.

 ex)   8 << 2
       00001000  →  00100000  →  32 

 >>  : 부호를 유지한 채 양수인 경우  0 , 음수인 경우에는 빈자리를  1 로 채운다.

 ex)  -8 >> 2
       11111000  →  11111110  →  -2

       8 >> 2
       00001000  →  00000010  →  2 
 

 

  ■ 관계 연산자 ( <, >, <=, >=, ==, !=)

  : 두 피연산자를 비교한다. 반환 값은  true 와  false 뿐이다.

    == 는 같은지 비교하는 연산자이고  != 는 다른지 비교하는 연산자이다.

   참조형에는 사용할 수 없다.

 

 

  ■ 논리 연산자 (&&, ||, !)

  :  && 는 AND연산,  || 는 OR연산,  ! 는 NOT연산을 수행한다. 논리 연산자는 피연산자로  boolean형  또는  boolean형 값을 반환하는 조건식 만을 허용한다. AND와 OR가 동시에 있을 경우 AND를 먼저 수행한다.

X	Y	X && Y	X || Y
true	true	true	true
true	false	false	true
false	true	false	true
false	false	false	false
NOT 연산 :  !true  →  false  /  !false  →  true 

 

 

  ■ 삼항 연산자 ( ? : )

  조건식  ?  (true일 때 실행될 내용)  :  (false일 때 실행될 내용)

  조건식이  true 일 경우에는 파란색 부분이 실행되고,  false 일 경우는 빨간색 부분이 실행된다.

 

 

  ■ 대입 연산자(==, +=, -=, *=, /=, %=, <<=, >==, &=, ^=, |= )

  대입 연산자를 기준으로 오른쪽의 값을 왼쪽에 저장한다.

  ex)   x = 5  →  x 에  5 를 대입

 

   == 를 제외한 나머지들은 복합 대입 연산자로  = 앞의 연산자로 양쪽의 값을 계산한 뒤에 그 값을 다시 왼쪽에 저장한다.

  ex)  x += 3  →  x  = x + 3

